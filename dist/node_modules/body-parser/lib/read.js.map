{"version":3,"sources":["../../../../node_modules/body-parser/lib/read.js"],"names":["createError","require","getBody","iconv","onFinished","zlib","module","exports","read","req","res","next","parse","debug","options","length","opts","stream","_body","encoding","verify","contentstream","inflate","undefined","err","encodingExists","toUpperCase","charset","toLowerCase","type","error","body","_error","resume","onfinished","str","decode","headers","createInflate","pipe","createGunzip"],"mappings":"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","file":"read.js","sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar createError = require('http-errors')\nvar getBody = require('raw-body')\nvar iconv = require('iconv-lite')\nvar onFinished = require('on-finished')\nvar zlib = require('zlib')\n\n/**\n * Module exports.\n */\n\nmodule.exports = read\n\n/**\n * Read a request into a buffer and parse.\n *\n * @param {object} req\n * @param {object} res\n * @param {function} next\n * @param {function} parse\n * @param {function} debug\n * @param {object} options\n * @private\n */\n\nfunction read (req, res, next, parse, debug, options) {\n  var length\n  var opts = options\n  var stream\n\n  // flag as parsed\n  req._body = true\n\n  // read options\n  var encoding = opts.encoding !== null\n    ? opts.encoding\n    : null\n  var verify = opts.verify\n\n  try {\n    // get the content stream\n    stream = contentstream(req, debug, opts.inflate)\n    length = stream.length\n    stream.length = undefined\n  } catch (err) {\n    return next(err)\n  }\n\n  // set raw-body options\n  opts.length = length\n  opts.encoding = verify\n    ? null\n    : encoding\n\n  // assert charset is supported\n  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {\n    return next(createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n      charset: encoding.toLowerCase(),\n      type: 'charset.unsupported'\n    }))\n  }\n\n  // read body\n  debug('read body')\n  getBody(stream, opts, function (error, body) {\n    if (error) {\n      var _error\n\n      if (error.type === 'encoding.unsupported') {\n        // echo back charset\n        _error = createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n          charset: encoding.toLowerCase(),\n          type: 'charset.unsupported'\n        })\n      } else {\n        // set status code on error\n        _error = createError(400, error)\n      }\n\n      // read off entire request\n      stream.resume()\n      onFinished(req, function onfinished () {\n        next(createError(400, _error))\n      })\n      return\n    }\n\n    // verify\n    if (verify) {\n      try {\n        debug('verify body')\n        verify(req, res, body, encoding)\n      } catch (err) {\n        next(createError(403, err, {\n          body: body,\n          type: err.type || 'entity.verify.failed'\n        }))\n        return\n      }\n    }\n\n    // parse\n    var str = body\n    try {\n      debug('parse body')\n      str = typeof body !== 'string' && encoding !== null\n        ? iconv.decode(body, encoding)\n        : body\n      req.body = parse(str)\n    } catch (err) {\n      next(createError(400, err, {\n        body: str,\n        type: err.type || 'entity.parse.failed'\n      }))\n      return\n    }\n\n    next()\n  })\n}\n\n/**\n * Get the content stream of the request.\n *\n * @param {object} req\n * @param {function} debug\n * @param {boolean} [inflate=true]\n * @return {object}\n * @api private\n */\n\nfunction contentstream (req, debug, inflate) {\n  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase()\n  var length = req.headers['content-length']\n  var stream\n\n  debug('content-encoding \"%s\"', encoding)\n\n  if (inflate === false && encoding !== 'identity') {\n    throw createError(415, 'content encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    })\n  }\n\n  switch (encoding) {\n    case 'deflate':\n      stream = zlib.createInflate()\n      debug('inflate body')\n      req.pipe(stream)\n      break\n    case 'gzip':\n      stream = zlib.createGunzip()\n      debug('gunzip body')\n      req.pipe(stream)\n      break\n    case 'identity':\n      stream = req\n      stream.length = length\n      break\n    default:\n      throw createError(415, 'unsupported content encoding \"' + encoding + '\"', {\n        encoding: encoding,\n        type: 'encoding.unsupported'\n      })\n  }\n\n  return stream\n}\n"]}