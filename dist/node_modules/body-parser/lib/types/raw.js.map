{"version":3,"sources":["../../../../../node_modules/body-parser/lib/types/raw.js"],"names":["bytes","require","debug","read","typeis","module","exports","raw","options","opts","inflate","limit","parse","type","verify","TypeError","shouldParse","typeChecker","buf","rawParser","req","res","next","_body","body","hasBody","headers","encoding","checkType","Boolean"],"mappings":"AAAA;;;;;;AAMA;;AAEA;;;;AAIA,IAAIA,QAAQC,QAAQ,OAAR,CAAZ;AACA,IAAIC,QAAQD,QAAQ,OAAR,EAAiB,iBAAjB,CAAZ;AACA,IAAIE,OAAOF,QAAQ,SAAR,CAAX;AACA,IAAIG,SAASH,QAAQ,SAAR,CAAb;;AAEA;;;;AAIAI,OAAOC,OAAP,GAAiBC,GAAjB;;AAEA;;;;;;;;AAQA,SAASA,GAAT,CAAcC,OAAd,EAAuB;AACrB,MAAIC,OAAOD,WAAW,EAAtB;;AAEA,MAAIE,UAAUD,KAAKC,OAAL,KAAiB,KAA/B;AACA,MAAIC,QAAQ,OAAOF,KAAKE,KAAZ,KAAsB,QAAtB,GACRX,MAAMY,KAAN,CAAYH,KAAKE,KAAL,IAAc,OAA1B,CADQ,GAERF,KAAKE,KAFT;AAGA,MAAIE,OAAOJ,KAAKI,IAAL,IAAa,0BAAxB;AACA,MAAIC,SAASL,KAAKK,MAAL,IAAe,KAA5B;;AAEA,MAAIA,WAAW,KAAX,IAAoB,OAAOA,MAAP,KAAkB,UAA1C,EAAsD;AACpD,UAAM,IAAIC,SAAJ,CAAc,gCAAd,CAAN;AACD;;AAED;AACA,MAAIC,cAAc,OAAOH,IAAP,KAAgB,UAAhB,GACdI,YAAYJ,IAAZ,CADc,GAEdA,IAFJ;;AAIA,WAASD,KAAT,CAAgBM,GAAhB,EAAqB;AACnB,WAAOA,GAAP;AACD;;AAED,SAAO,SAASC,SAAT,CAAoBC,GAApB,EAAyBC,GAAzB,EAA8BC,IAA9B,EAAoC;AACzC,QAAIF,IAAIG,KAAR,EAAe;AACbrB,YAAM,qBAAN;AACAoB;AACA;AACD;;AAEDF,QAAII,IAAJ,GAAWJ,IAAII,IAAJ,IAAY,EAAvB;;AAEA;AACA,QAAI,CAACpB,OAAOqB,OAAP,CAAeL,GAAf,CAAL,EAA0B;AACxBlB,YAAM,iBAAN;AACAoB;AACA;AACD;;AAEDpB,UAAM,iBAAN,EAAyBkB,IAAIM,OAAJ,CAAY,cAAZ,CAAzB;;AAEA;AACA,QAAI,CAACV,YAAYI,GAAZ,CAAL,EAAuB;AACrBlB,YAAM,cAAN;AACAoB;AACA;AACD;;AAED;AACAnB,SAAKiB,GAAL,EAAUC,GAAV,EAAeC,IAAf,EAAqBV,KAArB,EAA4BV,KAA5B,EAAmC;AACjCyB,gBAAU,IADuB;AAEjCjB,eAASA,OAFwB;AAGjCC,aAAOA,KAH0B;AAIjCG,cAAQA;AAJyB,KAAnC;AAMD,GAhCD;AAiCD;;AAED;;;;;;;AAOA,SAASG,WAAT,CAAsBJ,IAAtB,EAA4B;AAC1B,SAAO,SAASe,SAAT,CAAoBR,GAApB,EAAyB;AAC9B,WAAOS,QAAQzB,OAAOgB,GAAP,EAAYP,IAAZ,CAAR,CAAP;AACD,GAFD;AAGD","file":"raw.js","sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n */\n\nvar bytes = require('bytes')\nvar debug = require('debug')('body-parser:raw')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = raw\n\n/**\n * Create a middleware to parse raw bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @api public\n */\n\nfunction raw (options) {\n  var opts = options || {}\n\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'application/octet-stream'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (buf) {\n    return buf\n  }\n\n  return function rawParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: null,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n"]}