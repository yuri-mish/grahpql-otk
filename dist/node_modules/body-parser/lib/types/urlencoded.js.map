{"version":3,"sources":["../../../../../node_modules/body-parser/lib/types/urlencoded.js"],"names":["bytes","require","contentType","createError","debug","deprecate","read","typeis","module","exports","urlencoded","parsers","Object","create","options","opts","extended","undefined","inflate","limit","parse","type","verify","TypeError","queryparse","extendedparser","simpleparser","shouldParse","typeChecker","body","length","urlencodedParser","req","res","next","_body","hasBody","headers","charset","getCharset","toUpperCase","encoding","parameterLimit","parser","isNaN","isFinite","paramCount","parameterCount","arrayLimit","Math","max","allowPrototypes","depth","Infinity","parameters","toLowerCase","e","count","index","indexOf","name","mod","maxKeys","checkType","Boolean"],"mappings":"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","file":"urlencoded.js","sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:urlencoded')\nvar deprecate = require('depd')('body-parser')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = urlencoded\n\n/**\n * Cache of parser modules.\n */\n\nvar parsers = Object.create(null)\n\n/**\n * Create a middleware to parse urlencoded bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction urlencoded (options) {\n  var opts = options || {}\n\n  // notice because option default will flip in next major\n  if (opts.extended === undefined) {\n    deprecate('undefined extended: provide extended option')\n  }\n\n  var extended = opts.extended !== false\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'application/x-www-form-urlencoded'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate query parser\n  var queryparse = extended\n    ? extendedparser(opts)\n    : simpleparser(opts)\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (body) {\n    return body.length\n      ? queryparse(body)\n      : {}\n  }\n\n  return function urlencodedParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // assert charset\n    var charset = getCharset(req) || 'utf-8'\n    if (charset !== 'utf-8') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      debug: debug,\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the extended query parser.\n *\n * @param {object} options\n */\n\nfunction extendedparser (options) {\n  var parameterLimit = options.parameterLimit !== undefined\n    ? options.parameterLimit\n    : 1000\n  var parse = parser('qs')\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse (body) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      })\n    }\n\n    var arrayLimit = Math.max(100, paramCount)\n\n    debug('parse extended urlencoding')\n    return parse(body, {\n      allowPrototypes: true,\n      arrayLimit: arrayLimit,\n      depth: Infinity,\n      parameterLimit: parameterLimit\n    })\n  }\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Count the number of parameters, stopping once limit reached\n *\n * @param {string} body\n * @param {number} limit\n * @api private\n */\n\nfunction parameterCount (body, limit) {\n  var count = 0\n  var index = 0\n\n  while ((index = body.indexOf('&', index)) !== -1) {\n    count++\n    index++\n\n    if (count === limit) {\n      return undefined\n    }\n  }\n\n  return count\n}\n\n/**\n * Get parser for module name dynamically.\n *\n * @param {string} name\n * @return {function}\n * @api private\n */\n\nfunction parser (name) {\n  var mod = parsers[name]\n\n  if (mod !== undefined) {\n    return mod.parse\n  }\n\n  // this uses a switch for static require analysis\n  switch (name) {\n    case 'qs':\n      mod = require('qs')\n      break\n    case 'querystring':\n      mod = require('querystring')\n      break\n  }\n\n  // store to prevent invoking require()\n  parsers[name] = mod\n\n  return mod.parse\n}\n\n/**\n * Get the simple query parser.\n *\n * @param {object} options\n */\n\nfunction simpleparser (options) {\n  var parameterLimit = options.parameterLimit !== undefined\n    ? options.parameterLimit\n    : 1000\n  var parse = parser('querystring')\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse (body) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      })\n    }\n\n    debug('parse urlencoding')\n    return parse(body, undefined, undefined, { maxKeys: parameterLimit })\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n"]}